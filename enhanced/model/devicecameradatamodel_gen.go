// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.3

package model

import (
	"context"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"time"
	"go.mongodb.org/mongo-driver/bson/primitive"
)
type (
	deviceCameraDataModel interface {
		Insert(ctx context.Context, data *DeviceCameraData) (*mongo.InsertOneResult, error)
		FindOne(ctx context.Context, id int64) (*DeviceCameraData, error)
		FindOneByDeviceSnTimestamp(ctx context.Context, deviceSn string, timestamp int64) (*DeviceCameraData, error)
		FindByDeviceSnTimeRange(ctx context.Context, deviceSn string, startTimestamp int64, endTimestamp int64) ([]*DeviceCameraData, error)
		Update(ctx context.Context, data *DeviceCameraData) (*mongo.UpdateResult, error)
		Upsert(ctx context.Context, data []*DeviceCameraData)  (*BatchResult, error)
		Delete(ctx context.Context, id int64)  error
	}

	defaultDeviceCameraDataModel struct {
		conn  *mongo.Client
		table string
	}

	DeviceCameraData struct {
		Id           int64   `bson:"id"`
		DeviceSn     string  `bson:"device_sn"`
		Timestamp    time.Time   `bson:"timestamp"`
		IsFixed      int64   `bson:"is_fixed"`
		BatteryLevel uint64  `bson:"battery_level"`
		RotationX    float64 `bson:"rotation_x"`
		RotationY    float64 `bson:"rotation_y"`
		RotationZ    float64 `bson:"rotation_z"`
	}
)

func newDeviceCameraDataModel(conn *mongo.Client) *defaultDeviceCameraDataModel {
	return &defaultDeviceCameraDataModel{
		conn:  conn,
		table: "device_data",
	}
}

func (m *defaultDeviceCameraDataModel) Delete(ctx context.Context, id int64) error {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.D{{"id", id}}
	_, err := collection.DeleteOne(ctx, filter)
	return err
}

func (m *defaultDeviceCameraDataModel) FindOne(ctx context.Context, id int64) (*DeviceCameraData, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.D{{"id", id}}
	var result DeviceCameraData
	err := collection.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

func (m *defaultDeviceCameraDataModel) FindOneByDeviceSnTimestamp(ctx context.Context, deviceSn string, timestamp int64) (*DeviceCameraData, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.D{{"device_sn", deviceSn}, {"timestamp", timestamp}}
	var result DeviceCameraData
	err := collection.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

func (m *defaultDeviceCameraDataModel) FindByDeviceSnTimeRange(ctx context.Context, deviceSn string, startTimestamp int64, endTimestamp int64) ([]*DeviceCameraData, error) {
	collection := m.conn.Database("test").Collection(m.table)
	t := time.Unix(startTimestamp, 0)
	startTime := primitive.NewDateTimeFromTime(t)
	t = time.Unix(endTimestamp, 0)
	endTime := primitive.NewDateTimeFromTime(t)
	filter := bson.D{{"device_sn", deviceSn}, {"timestamp", bson.D{{"$gte", startTime}, {"$lte", endTime}}}}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	var results []*DeviceCameraData
	if err = cursor.All(ctx, &results); err != nil {
		return nil, err
	}
	return results, nil
}

func (m *defaultDeviceCameraDataModel) Insert(ctx context.Context, data *DeviceCameraData) (*mongo.InsertOneResult, error) {
	collection := m.conn.Database("test").Collection(m.table)
	result, err := collection.InsertOne(ctx, data)
	return result, err
}

func (m *defaultDeviceCameraDataModel) Update(ctx context.Context, newData *DeviceCameraData) (*mongo.UpdateResult, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.D{{"id", newData.Id}}
	update := bson.D{{"$set", bson.D{{"device_sn", newData.DeviceSn}, {"timestamp", newData.Timestamp}, {"is_fixed", newData.IsFixed}, {"battery_level", newData.BatteryLevel}, {"rotation_x", newData.RotationX}, {"rotation_y", newData.RotationY}, {"rotation_z", newData.RotationZ}}}}
	result, err := collection.UpdateOne(ctx, filter, update)
	return result, err
}



func (m *defaultDeviceCameraDataModel) Upsert(ctx context.Context, data []*DeviceCameraData) (*BatchResult, error) {
	if len(data) == 0 {
		return &BatchResult{}, nil
	}
	result := &BatchResult{}
	collection := m.conn.Database("test").Collection(m.table)
	// Process data in batches
	for i := 0; i < len(data); i += BatchSize {
		end := i + BatchSize
		if end > len(data) {
			end = len(data)
		}
		// Get current batch data
		batchData := data[i:end]
		// Prepare bulk write operations
		var operations []mongo.WriteModel
		for _, item := range batchData {
            bsonDateTime := primitive.NewDateTimeFromTime(item.Timestamp)

			update := bson.D{
				{"id", item.Id},
				{"device_sn", item.DeviceSn},
				{"timestamp", bsonDateTime},
				{"is_fixed", item.IsFixed},
				{"battery_level", item.BatteryLevel},
				{"rotation_x", item.RotationX},
				{"rotation_y", item.RotationY},
				{"rotation_z", item.RotationZ},
			}
			//upsert := true
			//model := mongo.NewUpdateOneModel().SetFilter(filter).SetUpdate(update).SetUpsert(upsert)
			model := mongo.NewInsertOneModel().SetDocument(update)
			operations = append(operations, model)
		}
		// Execute bulk write
		bulkOptions := options.BulkWrite().SetOrdered(false)
		bulkResult, err := collection.BulkWrite(ctx, operations, bulkOptions)
		if err != nil {
			result.FailedBatch = append(result.FailedBatch, i/BatchSize)
			result.Err = err
			continue
		}
		result.SuccessCount += int(bulkResult.ModifiedCount + bulkResult.UpsertedCount)
	}
	return result, nil
}

func (m *defaultDeviceCameraDataModel) tableName() string {
	return m.table
}
