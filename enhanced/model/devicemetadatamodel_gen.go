// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.3

package model

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type Param struct {
	PV string    `bson:"pv"`
	CT time.Time `bson:"ct"`
	UT time.Time `bson:"ut"`
}

type DeviceMetadata struct {
	DeviceSn string           `bson:"device_sn"`
	Params   map[string]Param `bson:"params"`
}

type deviceMetadataModel interface {
	Insert(ctx context.Context, data *DeviceMetadata) (*mongo.InsertOneResult, error)
	FindOne(ctx context.Context, id int64) (*DeviceMetadata, error)
	FindByDeviceSn(ctx context.Context, deviceSn string) ([]*DeviceMetadata, error)
	FindOneByDeviceSnParamType(ctx context.Context, deviceSn string, paramType int64) (*DeviceMetadata, error)
	Update(ctx context.Context, data *DeviceMetadata) (*mongo.UpdateResult, error)
	Upsert(ctx context.Context, data []*DeviceMetadata) (*BatchResult, error)
	Delete(ctx context.Context, id int64) error
}

type defaultDeviceMetadataModel struct {
	conn  *mongo.Client
	table string
}

func newDeviceMetadataModel(conn *mongo.Client) *defaultDeviceMetadataModel {
	return &defaultDeviceMetadataModel{
		conn:  conn,
		table: "device_metadata",
	}
}

func (m *defaultDeviceMetadataModel) Insert(ctx context.Context, data *DeviceMetadata) (*mongo.InsertOneResult, error) {
	collection := m.conn.Database("test").Collection(m.table)
	res, err := collection.InsertOne(ctx, data)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (m *defaultDeviceMetadataModel) FindOne(ctx context.Context, id int64) (*DeviceMetadata, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"params.id": id}
	var result DeviceMetadata
	err := collection.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

func (m *defaultDeviceMetadataModel) FindByDeviceSn(ctx context.Context, deviceSn string) ([]*DeviceMetadata, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"device_sn": deviceSn}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	var results []*DeviceMetadata
	if err = cursor.All(ctx, &results); err != nil {
		return nil, err
	}
	return results, nil
}

func (m *defaultDeviceMetadataModel) FindOneByDeviceSnParamType(ctx context.Context, deviceSn string, paramType int64) (*DeviceMetadata, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"device_sn": deviceSn, "params." + string(paramType): bson.M{"$exists": true}}
	var result DeviceMetadata
	err := collection.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

func (m *defaultDeviceMetadataModel) Update(ctx context.Context, data *DeviceMetadata) (*mongo.UpdateResult, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"device_sn": data.DeviceSn}
	update := bson.M{"$set": bson.M{"params": data.Params}}
	res, err := collection.UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, err
	}
	return res, nil
}

const BatchSize = 1000

type BatchResult struct {
	SuccessCount int
	FailedBatch  []int
	Err          error
}

func (m *defaultDeviceMetadataModel) Upsert(ctx context.Context, data []*DeviceMetadata) (*BatchResult, error) {
	if len(data) == 0 {
		return &BatchResult{}, nil
	}
	result := &BatchResult{}
	collection := m.conn.Database("test").Collection(m.table)
	// Process data in batches
	for i := 0; i < len(data); i += BatchSize {
		end := i + BatchSize
		if end > len(data) {
			end = len(data)
		}
		// Get current batch data
		batchData := data[i:end]
		// Prepare bulk write operations
		var operations []mongo.WriteModel
		for _, item := range batchData {
			filter := bson.M{"device_sn": item.DeviceSn}
			update := bson.M{"$set": bson.M{"params": item.Params}}
			upsert := true
			model := mongo.NewUpdateOneModel().SetFilter(filter).SetUpdate(update).SetUpsert(upsert)
			operations = append(operations, model)
		}
		// Execute bulk write
		bulkOptions := options.BulkWrite().SetOrdered(false)
		bulkResult, err := collection.BulkWrite(ctx, operations, bulkOptions)
		if err != nil {
			result.FailedBatch = append(result.FailedBatch, i/BatchSize)
			result.Err = err
			continue
		}
		result.SuccessCount += int(bulkResult.ModifiedCount + bulkResult.UpsertedCount)
	}
	return result, nil
}


func (m *defaultDeviceMetadataModel) Delete(ctx context.Context, id int64) error {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"params.id": id}
	res, err := collection.DeleteOne(ctx, filter)
	if err != nil {
		return err
	}
	if res.DeletedCount == 0 {
		return mongo.ErrNoDocuments
	}
	return nil
}


func (m *defaultDeviceMetadataModel) tableName() string {
	return m.table
}
