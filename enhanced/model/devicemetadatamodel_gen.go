// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.7.3

package model

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

var (
	deviceMetadataFieldNames          = bson.M{"id": 1, "device_sn": 1, "param_type": 1, "param_value": 1, "create_time": 1, "update_time": 1}
	deviceMetadataRows                = deviceMetadataFieldNames
	deviceMetadataRowsExpectAutoSet   = bson.M{"device_sn": 1, "param_type": 1, "param_value": 1}
	deviceMetadataRowsWithPlaceHolder = deviceMetadataRowsExpectAutoSet
)

type (
	deviceMetadataModel interface {
		Insert(ctx context.Context, data *DeviceMetadata) (*mongo.InsertOneResult, error)
		FindOne(ctx context.Context, id int64) (*DeviceMetadata, error)
		FindByDeviceSn(ctx context.Context, deviceSn string) ([]*DeviceMetadata, error)
		FindOneByDeviceSnParamType(ctx context.Context, deviceSn string, paramType int64) (*DeviceMetadata, error)
		Update(ctx context.Context, data *DeviceMetadata) (*mongo.UpdateResult, error)
		Upsert(ctx context.Context, data []*DeviceMetadata) (*BatchResult, error) 
		Delete(ctx context.Context, id int64) error
	}

	defaultDeviceMetadataModel struct {
		conn  *mongo.Client
		table string
	}

	DeviceMetadata struct {
		Id         int64     `bson:"id"`
		DeviceSn   string    `bson:"device_sn"`   // device sn
		ParamType  int64     `bson:"param_type"`  // param type
		ParamValue string    `bson:"param_value"` // param value
		CreateTime time.Time `bson:"create_time"` // create time
		UpdateTime time.Time `bson:"update_time"` // update time
	}
)

func newDeviceMetadataModel(conn *mongo.Client) *defaultDeviceMetadataModel {
	return &defaultDeviceMetadataModel{
		conn:  conn,
		table: "device_metadata",
	}
}

func (m *defaultDeviceMetadataModel) Delete(ctx context.Context, id int64) error {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"id": id}
	res, err := collection.DeleteOne(ctx, filter)
	if err != nil {
		return err
	}
	if res.DeletedCount == 0 {
		return mongo.ErrNoDocuments
	}
	return nil
}

func (m *defaultDeviceMetadataModel) FindOne(ctx context.Context, id int64) (*DeviceMetadata, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"id": id}
	var result DeviceMetadata
	err := collection.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

func (m *defaultDeviceMetadataModel) FindByDeviceSn(ctx context.Context, deviceSn string) ([]*DeviceMetadata, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"device_sn": deviceSn}
	cursor, err := collection.Find(ctx, filter)
	if err != nil {
		return nil, err
	}
	var results []*DeviceMetadata
	if err = cursor.All(ctx, &results); err != nil {
		return nil, err
	}
	return results, nil
}

func (m *defaultDeviceMetadataModel) FindOneByDeviceSnParamType(ctx context.Context, deviceSn string, paramType int64) (*DeviceMetadata, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"device_sn": deviceSn, "param_type": paramType}
	var result DeviceMetadata
	err := collection.FindOne(ctx, filter).Decode(&result)
	if err != nil {
		return nil, err
	}
	return &result, nil
}

func (m *defaultDeviceMetadataModel) Insert(ctx context.Context, data *DeviceMetadata) (*mongo.InsertOneResult, error) {
	collection := m.conn.Database("test").Collection(m.table)
	res, err := collection.InsertOne(ctx, data)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (m *defaultDeviceMetadataModel) Update(ctx context.Context, newData *DeviceMetadata) (*mongo.UpdateResult, error) {
	collection := m.conn.Database("test").Collection(m.table)
	filter := bson.M{"id": newData.Id}
	update := bson.M{"$set": bson.M{"device_sn": newData.DeviceSn, "param_type": newData.ParamType, "param_value": newData.ParamValue}}
	res, err := collection.UpdateOne(ctx, filter, update)
	if err != nil {
		return nil, err
	}
	return res, nil
}

const BatchSize = 1000

// BatchResult stores the execution results of batch processing
type BatchResult struct {
    SuccessCount int      // Number of successfully processed records
    FailedBatch  []int    // Indexes of failed batches
    Err          error    // Last error encountered
}

func (m *defaultDeviceMetadataModel) Upsert(ctx context.Context, data []*DeviceMetadata) (*BatchResult, error) {
    if len(data) == 0 {
        return &BatchResult{}, nil
    }

    result := &BatchResult{}
    
    // Process data in batches
    for i := 0; i < len(data); i += BatchSize {
        end := i + BatchSize
        if end > len(data) {
            end = len(data)
        }
        
        // Get current batch data
        batchData := data[i:end]
        
        // Execute current batch within a transaction
        session, err := m.conn.StartSession()
        if err != nil {
            return nil, err
        }
        session.StartTransaction()
        defer session.EndSession(ctx)
        
        for _, item := range batchData {
            filter := bson.M{"device_sn": item.DeviceSn, "param_type": item.ParamType}
            update := bson.M{"$set": bson.M{"param_value": item.ParamValue}}
            _, err := m.conn.Database("test").Collection(m.table).UpdateOne(ctx, filter, update, options.Update().SetUpsert(true))
            if err != nil {
                session.AbortTransaction(ctx)
                result.FailedBatch = append(result.FailedBatch, i/BatchSize)
                result.Err = err
                return result, err
            }
        }
        
        err = session.CommitTransaction(ctx)
        if err != nil {
            return nil, err
        }
        
        result.SuccessCount += len(batchData)
    }
    
    return result, nil
}

func (m *defaultDeviceMetadataModel) tableName() string {
	return m.table
}
